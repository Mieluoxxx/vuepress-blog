---
title: Rust并发3 同步
---
同步指的是线程之间的协作配合，以共同完成某个任务。在整个过程中，需要注意两个关键点：一是共享资源的访问， 二是访问资源的顺序。通过前面的介绍，我们已经知道了如何让多个线程访问共享资源，但并没介绍如何控制访问顺序，才不会出现错误。如果两个线程同时访问同一内存地址的数据，一个写，一个读，如果不加控制，写线程只写了一半，读线程就开始读，必然读到的数据是错误的，不可用的，从而造成程序错误，这就造成了并发安全问题，为此我们必须要有一套控制机制来避免这样的事情发生。就好比两个人喝一瓶可乐，只有一根吸管，那肯定也得商量出一个规则，才能相安无事地都喝到可乐。本节就将具体介绍在Rust中，我们要怎么做，才能解决这个问题。
继续上面喝可乐的例子，一人一口的方式，就是一种解决方案，只要不是太笨，几乎都能想到这个方案。具体实施时，A在喝的时候，B一直在旁边盯着，要是A喝完一口，B马上拿过来喝，此时A肯定也是在旁边盯着。在现实生活中，这样的示例比比皆是。细想一下，貌似同步中都可能涉及到等待。诸葛先生在万事具备，只欠东风时，也只能等，因为条件不成熟啊。依照这个逻辑，在操作系统和各大编程语言中，几乎都支持当前线程等待，当然Rust也不例外

## 等待

Rust中线程等待和其他语言在机制上并无差异，大致有下面几种：

- 等待一段时间后，再接着继续执行。看起来就像一个人工作累了，休息一会再工作。通过调用相关的API可以让当前线程暂停执行进入睡眠状态，此时调度器不会调度它执行，等过一段时间后，线程自动进入就绪状态，可以被调度执行，继续从之前睡眠时的地方执行。对应的API有`std::thread::sleep`，`std::thread::sleep_ms`，`std::thread::park_timeout`，`std::thread::park_timeout_ms`，还有一些类似的其他API，由于太多，详细信息就请参见官网[`std::thread`](https://doc.rust-lang.org/stable/std/thread/index.html)。
- 这一种方式有点特殊，时间非常短，就一个时间片，当前线程自己主动放弃当前时间片的调度，让调度器重新选择线程来执行，这样就把运行机会给了别的线程，但是要注意的是，如果别的线程没有更好的理由执行，当然最后执行机会还是它的。在实际的应用业务中，比如生产者制造出一个产品后，可以放弃一个时间片，让消费者获得执行机会，从而快速地消费才生产的产品。这样的控制粒度非常小，需要合理使用，如果需要连续放弃多个时间片，可以借用循环实现。对应的API是`std::thread::yield_now`，详细信息参见官网[`std::thread`](https://doc.rust-lang.org/stable/std/thread/index.html)。
- 1和2的等待都无须其他线程的协助，即可在一段时间后继续执行。最后我们还遇到一种等待，是需要其他线程参与，才能把等待的线程叫醒，否则，线程会一直等待下去。好比一个女人，要是没有遇到一个男人，就永远不可能摆脱单身的状态。相关的API包括`std::thread::JoinHandle::join`，`std::thread::park`，`std::sync::Mutex::lock`等，还有一些同步相关的类的API也会导致线程等待。详细信息参见官网[`std::thread`](https://doc.rust-lang.org/stable/std/thread/index.html)和[`std::sync`](https://doc.rust-lang.org/stable/std/sync/index.html)。

第一种和第三种等待方式，其实我们在上面的介绍中，都已经遇到过了，它们也是使用的最多的两种方式。在此，也可以回过头去看看前面的使用方式和使用效果，结合自己的理解，做一些简单的练习。

毫无疑问，第三种方式稍显复杂，要将等待的线程叫醒，必然基于一定的规则，比如早上7点必须起床，那么就定一个早上7点的闹钟，到时间了就响，没到时间别响。不管基于什么规则，要触发叫醒这个事件，就肯定是某个条件已经达成了。基于这样的逻辑，在操作系统和编程语言中，引入了一种叫着**条件变量**的东西。可以模拟现实生活中的闹钟的行为，条件达成就通知等待条件的线程。Rust的条件变量就是`std::sync::Condvar`，详情参见官网[条件变量](https://doc.rust-lang.org/std/sync/struct.Condvar.html)。但是通知也并不只是条件变量的专利，还有其他的方式也可以触发通知，下面我们就来瞧一瞧。

## 通知

看是简单的通知，在编程时也需要注意以下几点：

- 通知必然是因为有等待，所以通知和等待几乎都是成对出现的，比如`std::sync::Condvar::wait`和`std::sync::Condvar::notify_one`，`std::sync::Condvar::notify_all`。
- 等待所使用的对象，与通知使用的对象是同一个对象，从而该对象需要在多个线程之间共享，参见下面的例子。
- 除了`Condvar`之外，其实_锁_也是具有自动通知功能的，当持有锁的线程释放锁的时候，等待锁的线程就会自动被唤醒，以抢占锁。关于锁的介绍，在下面有详解。
- 通过条件变量和锁，还可以构建更加复杂的自动通知方式，比如`std::sync::Barrier`。
- 通知也可以是1:1的，也可以是1:N的，`Condvar`可以控制通知一个还是N个，而锁则不能控制，只要释放锁，所有等待锁的其他线程都会同时醒来，而不是只有最先等待的线程。