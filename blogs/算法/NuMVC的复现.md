---
title: NuMVC的复现
date: 2023/12/14 22:28:37
categories:
    - 算法
tags: 
    - 图论
---

## 最小顶点覆盖问题

在一个图 $G$ 中，$V$ 是图的节点，边 $E$ 是连接两个顶点的线。

顶点覆盖问题是指，在给定一个图中，找到一个子集，使得该子集中的顶点与图中的所有边都相连。

举个例子，下面是一个简单的图：

```
A--B
|  |
C--D
```

​	在这个图中，有四个顶点和四条边。如果我们选择顶点 A、B、C 作为子集，那么这个子集中的顶点与图中的所有边都相连。因此，这个子集是一个顶点覆盖。

最小顶点覆盖问题是指，在给定一个图中，找到一个顶点覆盖，使得该子集中的顶点数最少。

​	回到上面的例子，如果我们选择顶点 A、C 作为子集，那么这个子集中的顶点数就为 2，比之前的子集少了 1。因此，这个子集是这个图的最小顶点覆盖。



​	最小顶点覆盖问题是一个 **NP-hard** 问题，这意味着它很难找到最优解。但是，我们可以使用一些近似算法来找到一个近似最优解。



在实际应用中，最小顶点覆盖问题可以用来解决以下问题：

- 网络安全：可以用来确定需要保护的网络节点，以防止攻击。
- 运输：可以用来确定需要维护的道路或桥梁，以确保交通畅通。
- 通信：可以用来确定需要部署的通信设备，以确保通信网络的覆盖范围。

## 论文阅读

《NuMVC: An Efficient Local Search Algorithm for Minimum Vertex Cover》

### 摘要

​	最小顶点覆盖（MVC）问题是一个重要的 NP-hard 组合优化问题，对于理论和应用都具有重要意义。**局部搜索**在该问题上已经证明是成功的。然而，现有的MVC局部搜索算法存在**两个主要缺点**。首先，**它们同时选择一对顶点进行交换，这是耗时的**。其次，**尽管使用边权重技术来使搜索多样化，但这些算法缺乏减小权重的机制**。为了解决这些问题，我们提出了两个新的策略：**两阶段交换**和**带有遗忘的边权重策略**。**两阶段交换策略将分别选择两个顶点进行交换，并在两个阶段进行交换**。**带有遗忘的边权重策略不仅增加未覆盖边的权重，还会定期减小每条边的一些权重**。这些策略被用于设计一种新的MVC局部搜索算法，称为NuMVC。我们在标准基准测试集DIMACS和BHOSLIB上进行了大量的实验研究。与现有的启发式算法相比，实验结果表明，NuMVC在DIMACS基准测试中至少与最接近的竞争对手PLS相当，并且在BHOSLIB基准测试中明显优于所有竞争对手。此外，实验结果表明，NuMVC在随机实例和一些结构化实例上比当前最佳的精确算法找到最优解的时间更短。此外，我们通过实验分析研究了两个策略的有效性和运行时间行为。



### 摘要分析

​	局部搜索算法是用于解决 NP-hard 问题的一种常用方法。局部搜索算法从一个初始解开始，然后反复地探索其邻域，并移动到邻域中的最优解。在最小顶点覆盖问题中，局部搜索算法通常会通过交换顶点来探索邻域。**例如，一个局部搜索算法可能会从一个顶点覆盖开始，然后交换两个顶点的位置。如果交换后的顶点覆盖的大小更小，那么算法就会接受该交换。**

- 现有的大多数 MVC 局部搜索算法都是同时选择一对顶点进行交换。这种方法虽然简单，但效率低下。原因是，如果一个顶点覆盖中的顶点数很大，那么同时选择一对顶点进行交换的可能性很小。这意味着算法需要花费大量时间来进行无效的搜索。
- 现有的大多数 MVC 局部搜索算法都使用边权重技术来使搜索多样化。这些算法会首先为图中的每条边分配一个权重。然后，算法会从一个初始解开始，并根据边的权重来探索邻域。例如，如果一条边的权重很高，那么算法就更有可能从该边开始探索邻域。然而，这些算法缺乏减小权重的机制。这意味着，随着搜索的进行，边的权重会一直保持不变。这种情况可能会导致算法陷入局部最优解。例如，如果算法从一个初始解开始，该初始解是一个次优解。那么，算法可能会在该次优解附近进行搜索，并最终找到一个与该次优解等价的局部最优解。



NuMVC的**创新点**：

- 为了提高效率，NuMVC 算法使用了一种称为 “逐渐交换” 的方法。在逐渐交换方法中，算法从一个顶点开始，然后逐渐增加交换的顶点数。这种方法可以更有效地探索邻域，从而提高算法的效率。红色顶点表示初始顶点覆盖中的顶点。算法从顶点 A 开始，然后逐渐增加交换的顶点数。在第一步，算法交换顶点 A 和顶点 B。在第二步，算法交换顶点 A 和顶点 C。在第三步，算法交换顶点 A、B 和顶点 C。逐渐交换方法的效率要比同时选择一对顶点进行交换高得多。

- 为了解决这个问题，NuMVC 算法使用了一种称为 “权重衰减” 的方法。在权重衰减方法中，算法会随着搜索的进行逐渐减小边的权重。这种方法可以鼓励算法探索新的区域，并降低陷入局部最优解的风险。在实验中，NuMVC 算法在大多数实例上都比现有的 MVC 局部搜索算法要好。这表明，权重衰减方法可以有效地提高 MVC 局部搜索算法的性能。通过使用权重衰减方法，NuMVC 算法可以更有效地探索邻域，并提高找到最优解的概率。具体来说，权重衰减方法体现在以下几点：

    - 在搜索的开始阶段，算法会使用较高的边权重来探索邻域。这可以帮助算法快速找到一个初始解。

    - 随着搜索的进行，算法会逐渐减小边权重。这可以鼓励算法探索新的区域，并降低陷入局部最优解的风险。



### 介绍

​	本文提出了两种新策略，即两阶段交换和遗忘的边权重。



​	两阶段交换策略将交换过程分解为两个阶段，即**移除阶段**和**添加阶段**，并分别执行它们。**它首先选择一个顶点并将其从当前候选解中移除，然后在随机的未覆盖边上选择一个顶点并添加它。**两阶段交换策略为MVC局部搜索提供了一种高效的两遍移动操作符，其中**第一遍是寻找要移除的顶点的线性时间搜索**，而**第二遍是寻找要添加的顶点的线性时间搜索**。这与标准的二次、一次性移动操作符形成对比。此外，两阶段交换策略使算法更加灵活，我们可以在不同阶段使用不同的启发式方法。实际上，NuMVC算法**在移除阶段使用了一种高度贪婪的启发式方法**，而在添加阶段，它充分利用了类似于**专注随机行走方法**（Papadimitriou，1991）的框架中的多样性启发式方法。



​	我们提出的第二个策略是带有遗忘机制的边权重。它在每一步增加未覆盖边的权重1。此外，当平均边权重达到阈值时，它通过将所有边的权重乘以一个常数因子 $ρ$（0 < $ ρ $ < 1）来减少边的权重，以遗忘之前的权重决策。据我们所知，这是第一次将遗忘机制引入MVC的局部搜索算法中。



### 开场白

​	一个无向图 $ G = (V, E) $ 由一个顶点集合  $V $ 和一个边集合 $E ⊆ V × V$ 组成，其中每个边是 $V$ 的 2 元素子集。对于一条边 $e = \{u, v\}$，我们称顶点 $u$ 和 $v$ 是边 $e$ 的端点。两个顶点是邻居当且仅当它们都属于某个公共边。我们用 $N(v) = \{u ∈ V | \{u, v\} ∈ E\}$ 来表示一个顶点 $v$ 的邻居集合。



​	对于一个无向图 $G = (V, E)$，独立集是 $V$ 的一个子集，其中的元素之间没有边相邻，而团是 $V$ 的一个子集，其中的元素之间有边相邻。最大独立集和最大团问题是在图中寻找最大规模的独立集和团。



​	我们注意到这三个问题 MVC、MIS 和 MC 可以被看作是实验算法视角下的同一个问题的三种不同形式。



​	与大多数最先进的 MVC 局部搜索算法一样，NuMVC 使用了边权重方案。加权的无向图是一个无向图 $G = (V, E)$ 结合一个权重函数 $w$，使得每条边 $e ∈ E$ 都与一个非负整数 $w(e)$ 相关联。我们用 w 来表示所有边权重的均值。

​	设 $w$ 是 $G$ 的一个权重函数。对于候选解 $X$，我们将 $X$ 的成本设置为 $cost(G, X) = e∈E$ 且 $e$ 没有被 $X$ 覆盖 $w(e)$，这表示 $X$ 未覆盖边的总权重。我们将 $cost(G, X)$ 作为评估函数，NuMVC **偏好成本较低的候选解**。对于一个顶点 $v ∈ V$，$dscore(v) = cost(G, C) - cost(G, C')$，其中如果 $v ∈ C$，则 $C' = C\{v\}$；如果 $v ∉ C$，则 $C' = C ∪ {v}$，测量改变顶点 $v$ 的状态的好处。显然，对于一个顶点 $v ∈ C$，我们有 $dscore(v) ≤ 0$，而 $dscore$ 越大表示通过将其移出 $C$，覆盖边的损失越小。对于顶点 $v ∉ C$，我们有 $dscore(v) ≥ 0$，而 $dscore$ 越高表示通过将其加入 $C$，覆盖边的增加越大。



### 两阶段交换策略

​	和大多数最先进的MVC局部搜索算法一样，NuMVC是一个迭代的 k-顶点覆盖 算法。在寻找 k-顶点覆盖 时，NuMVC从当前候选解 $C$ 中移除一个顶点，然后继续寻找一个 (k-1)-顶点覆盖。从这个意义上说，**NuMVC的核心是一个 k-顶点覆盖 算法**，**给定一个正整数k，寻找一个k大小的顶点覆盖。为了找到一个k-顶点覆盖，NuMVC从一个大小为k的候选解 $C$ 开始，通过迭代交换两个顶点，直到 $C$ 成为一个顶点覆盖。**



​	大多数MVC局部搜索算法都根据某种启发式方法同时选择一对要交换的顶点，评估一对顶点不仅取决于这两个顶点的评估值（如dscore），还涉及到两个顶点之间的关系，比如它们是否属于同一条边。因此，评估所有候选顶点对的时间开销相对较大。



​	与先前的MVC局部搜索算法相比，NuMVC分别选择两个要交换的顶点，并将这两个选定的顶点分为两个阶段进行交换。**在每次迭代中，NuMVC首先选择一个具有最高 $dscore$ 的顶点 $u ∈ C$ 并将其移除。然后，NuMVC随机选择一个未覆盖的边 $e$，并选择 $e$ 中 $dscore$ 较高的一个端点 $v$，在一定的约束条件下将其添加到 $C$ 中**。



​	值得注意的是，这种两阶段交换策略在某种程度上类似于CSP（约束满足问题）的**最小冲突爬山启发式算法**（Minton，Johnston，Phillips和Laird，1992），该算法对于N皇后问题表现出出人意料的性能。



### 遗忘的边权重

​	本节中，我们介绍了一种称为遗忘的边权重技术，它在NuMVC中起着重要作用。提出的边权重遗忘策略的工作原理如下。**每条边都与一个正整数作为其权重相关联，而每个边的权重初始化为 $1$ 。然后，在每次迭代中，未覆盖的边的权重都增加1。此外，当平均权重达到一个阈值时，所有边的权重都会通过公式 $w(e) := ⌊ρ \cdot w(e)⌋$ 进行降低，其中 $ρ$ 是 $0$ 到 $1$ 之间的常数因子。**



​	需要注意的是，MVC局部搜索中的边权重技术，包括本文中介绍的技术，属于更一般的优化问题的惩罚思想



​	遗忘机制被引入到边权重策略中，以便定期减少边的权重，这对于NuMVC算法来说起到了相当大的贡献。遗忘机制背后的思想是，过去的权重决策不再有帮助，可能会误导搜索，因此应该比最近的权重决策更不重要。



​	举个例子：考虑某一步中具有 $w(e_1) = 1000$ 和 $w(e_2) = 100$ 的两条边 $e_1$ 和 $e2$ 。我们用 $∆w(e)$ 表示 $w(e)$ 的增加量。根据评估函数，下一段时间内，算法更有可能频繁地覆盖 $e_1$ 而不是 $e_2$，假设在这段时间内 $∆w(e_1) = 50$ 和 $∆w(e_2) = 500$，这将使得 $w(e1) = 1000 + 50 = 1050$ 和 $w(e2) = 100 + 500 = 600$。如果没有遗忘机制，算法在未来的搜索中仍然会更喜欢覆盖 $e_1$ 而不是 $e_2$。这是不合理的，因为在这段时间内，$e_2$ 被覆盖的步骤比 $e_1$ 少得多。因此，为了多样化的考虑，$e_2$ 应该更优先被覆盖。现在让我们来考虑带有遗忘机制的情况（假设我们的实验设置中 $ρ = 0.3$）。假设在算法执行遗忘时 $w(e1) = 1000$ 和 $w(e2) = 100$。遗忘机制将边的权重减小为 $w(e1) = 1000×0.3 = 300$ 和 $w(e2) = 100×0.3 = 30$ 。经过一段时间，有 $∆w(e1) = 50$ 和 $∆w(e2) = 500$，于是我们有 $w(e1) = 300 + 50 = 350$ 和 $w(e2) = 30 + 500 = 530$。在这种情况下，算法更倾向于在未来的搜索中覆盖 $e_2$ 而不 是 $e_1$，这是我们所期望的。



​	虽然在SAT的子句加权局部搜索算法中的平滑技术启发了NuMVC中的遗忘机制，但NuMVC中的遗忘机制与SAT局部搜索算法中的平滑技术有所不同。在NuMVC中使用的遗忘机制公式已被用于禁忌搜索的长期频率学习机制（Taillard，1994）中。然而，在Taillar的算法中，参数ρ（在本文中使用此术语）始终大于1，该公式用于对一种移动施加惩罚，而不是遗忘惩罚。



### NuMVC算法

![1702469501865.png](http://pic.moguw.top/i/2023/12/13/65799f7eb06d5.png)

算法解释：

​	为了提高效率，NuMVC 算法采用了一种称为 “CC配置检查” 的方法。在 CC 配置检查方法中，算法会首先检查交换后的顶点覆盖是否满足某些条件。如果满足这些条件，那么算法就不需要重新计算邻域中的所有顶点覆盖。



NuMVC 算法采用的 CC 配置检查策略如下：

- **检查交换后的顶点覆盖是否是连通的**。**如果不是连通的，那么交换后的顶点覆盖一定比初始顶点覆盖大**，**因此算法不需要重新计算邻域中的所有顶点覆盖**。
- **检查交换后的顶点覆盖是否包含初始顶点覆盖中所有边**。如果**包含**，**那么交换后的顶点覆盖一定比初始顶点覆盖小**，因此算法不需要重新计算邻域中的所有顶点覆盖。

​	$CC$ 策略的一种实现是维护一个**布尔数组** $confChange$ 用于顶点。在搜索过程中，那些 $confChange$ 值为 $0$ 的顶点被禁止加入 $C$。$confChange$ 数组被初始化为全 $1$ 数组。之后，当顶点 $v$ 从 $C$ 中移除时，将 $confChange(v)$ 重置为 $0$，并且当顶点 $v$ 改变其状态时，对于每个 $z ∈ N(v)$，将 $confChange(z)$ 设置为 $1$。



NuMVC解释：

1. 一开始，所有的边权重被初始化为 $1$，并根据此计算出顶点的 $dscore$；对于每一个顶点 $v$，$confChange(v)$ 被初始化为 $1$；然后，通过迭代地添加 $dscore$ 最高的顶点（相同 $dscore$ 的顶点随机选取），构建当前候选解$C$，直到 $C$ 成为一个顶点覆盖。最后，将最优解 $C^*$ 初始化为 $C$。
   
2. 初始化之后，循环（第7至18行）会不断执行，**直到达到给定的截止时间**。在搜索过程中，一旦没有未覆盖的边，即 $C$ 是一个顶点覆盖，NuMVC将 $C$ 作为最优解 $C^*$ 进行更新（第9行）。然后，它会从C中移除 $dscore$ 最高的一个顶点（随机选择其中一个，平局随机选择一个），以便继续搜索一个大小为 $|C|=|C^*|-1$ 的顶点覆盖。我们注意到，在 $C$ 中，具有最高 $dscore$ 的顶点具有最小的 $dscore$ 的绝对值，因为所有这些 $dscore$ 都是负数。
   
3. 在循环的每次迭代中，NuMVC会根据两阶段交换的策略（第12至16行）交换两个顶点。具体来说，它首先选择一个在 $C$ 中具有最高 $dscore$ 的顶点 $u$ 进行移除，优先选择**最老（年龄表示该顶点在搜索过程中被移除的次数）**的顶点来打破平局。在移除 $u$ 之后，NuMVC在未覆盖的边中均匀随机选择一条边 $e$，并按照以下方式选择 $e$ 的一个端点加入 $C$：如果只有一个端点的 $confChange$ 为$1$，则选择该顶点；如果两个端点的 $confChange$ 值均为 $1$，则 NuMVC 选择具有较高 $dscore$ 的顶点，优先选择最老的顶点来打破平局。通过将选定的顶点加入 $C$ 来完成交换。同时，$confChange$ 数组也相应地进行了更新。
   
4. 在每次迭代结束时，NuMVC算法更新边的权重（第17-18行）。首先，所有未覆盖的边的权重增加 $1$。此外，NuMVC利用遗忘机制周期性地减小权重。具体而言，**如果所有边的平均权重达到阈值 $γ$ ，则将所有边的权重乘以一个常数因子ρ（0 < ρ < 1），并向下取整作为边的权重**，因为NuMVC中的权重定义为**整数**。遗忘机制在一定程度上忘记了先前的权重决策，因为这些过去的影响通常不再有帮助，可能会误导搜索。
5. 对第15行可执行性的讨论：
    - 命题：对于一条未覆盖的边 $e$，至少有一个端点 $v$ 使得 $confChange(v) = 1$。
      
    - 证明：考虑任意一条未覆盖的边 $e = \{v1，v2\}$。证明分为两种情况。
        - $v_1$ 和 $v_2$ 中至少有一个在初始化后不会改变其状态。不失一般性，我们假设 $v_1$ 是这样的顶点。在初始化时，将 $confChange(v_1)$ 设置为$1$。之后，只有将 $v_1$ 从 $C$ 中移除（对应于 $v$ 的状态 $s$， $v$ 从 $1$ 变为$0$）会导致 $confChange(v_1)$ 等于 $0$，但是 $v_1$ 在初始化后不会改变其状态，所以我们有 $confChange(v_1) = 1$。
        - $v_1$ 和 $v_2$ 都在初始化后改变了它们的状态。由于 $e$ 是未覆盖的，我们有 $v_1∉C$ 和 $v_2∉C$。不失一般性，我们假设最后一次移除 $v_1$发生在最后一次移除 $v_2$ 之前。当最后一次移除 $v_1$ 时，有 $v_2 ∈ C$。之后，移除 $v_2$，这意味着 $v_2$ 改变了其状态，因此当 $v_1∈N(v_2)$ 时，将 $confChange(v_1)$ 设置为 $1$。



